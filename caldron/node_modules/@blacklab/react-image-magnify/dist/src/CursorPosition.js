"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CursorPosition = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const resize_observer_1 = __importDefault(require("@react-hook/resize-observer"));
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const TouchActivation_1 = require("./lib/TouchActivation");
const HoverActivation_1 = require("./lib/HoverActivation");
const ClickActivation_1 = require("./lib/ClickActivation");
const TapActivation_1 = require("./lib/TapActivation");
const PressActivation_1 = require("./lib/PressActivation");
const RelativeCursorPositionObserver_1 = require("./lib/RelativeCursorPositionObserver");
// TODO move to utils
const getTouchActivationStrategy = (interaction, onIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold) => {
    const { touch, tap, press, } = constants_1.INTERACTIONS;
    switch (interaction) {
        case press:
            return new PressActivation_1.PressActivation({
                onIsActiveChanged,
                pressDurationInMs,
                pressMoveThreshold,
            });
        case tap:
            return new TapActivation_1.TapActivation({
                onIsActiveChanged,
                tapDurationInMs,
                tapMoveThreshold,
            });
        case touch:
            return new TouchActivation_1.TouchActivation({
                onIsActiveChanged,
            });
        default:
            throw new Error('Must implement a touch activation strategy');
    }
};
const getMouseActivationStrategy = (interaction, onIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs) => {
    const { hover, click, } = constants_1.INTERACTIONS;
    switch (interaction) {
        case hover:
            return new HoverActivation_1.HoverActivation({
                onIsActiveChanged,
                hoverDelayInMs,
                hoverOffDelayInMs,
            });
        case click:
            return new ClickActivation_1.ClickActivation({
                onIsActiveChanged,
            });
        default:
            throw new Error('Must implement a mouse activation strategy');
    }
};
const getElementDimensions = (rect) => {
    const { width, height, } = rect;
    return {
        width,
        height,
    };
};
const getIsPositionOutside = (pos, elementDimensions) => {
    const { x, y } = pos;
    const { width, height, } = elementDimensions;
    return (x < 0
        || y < 0
        || x > width
        || y > height);
};
const getTouchEvent = (e) => e.touches[0];
const CursorPosition = (props) => {
    const { activationInteractionMouse, activationInteractionTouch, children, hoverDelayInMs = 250, hoverOffDelayInMs = 150, isEnabled = true, onActivationChanged = utils_1.noop, onDetectedEnvironmentChanged = utils_1.noop, onOutsideClick, onPositionChanged: onPositionChangedProp = utils_1.noop, pressDurationInMs = 500, pressMoveThreshold = 5, shouldStopTouchMovePropagation = false, style, tabIndex = -1, tapDurationInMs = 180, tapMoveThreshold = 5, useCapture } = props, rest = __rest(props, ["activationInteractionMouse", "activationInteractionTouch", "children", "hoverDelayInMs", "hoverOffDelayInMs", "isEnabled", "onActivationChanged", "onDetectedEnvironmentChanged", "onOutsideClick", "onPositionChanged", "pressDurationInMs", "pressMoveThreshold", "shouldStopTouchMovePropagation", "style", "tabIndex", "tapDurationInMs", "tapMoveThreshold", "useCapture"]);
    ///
    /// Refs
    ///
    const observer = (0, react_1.useRef)(new RelativeCursorPositionObserver_1.RelativeCursorPositionObserver());
    const divRef = (0, react_1.useRef)(null);
    const timersRef = (0, react_1.useRef)([]);
    ///
    /// State
    ///
    const [elementDimensions, setElementDimensions] = (0, react_1.useState)({
        width: 0,
        height: 0,
    });
    const [shouldGuardAgainstMouseEmulationByDevices, setShouldGuardAgainstMouseEmulationByDevices,] = (0, react_1.useState)(false);
    const [isActive, setIsActive] = (0, react_1.useState)(false);
    const [isPositionOutside, setIsPositionOutside] = (0, react_1.useState)(true);
    const [position, setPosition] = (0, react_1.useState)({
        x: 0,
        y: 0,
    });
    ///
    /// Hooks
    ///
    (0, resize_observer_1.default)(divRef, (entry) => setElementDimensions(getElementDimensions(entry.contentRect)));
    // TODO remove / replace
    const handleIsActiveChanged = (event) => {
        setIsActive(event.isActive);
    };
    const [touchActivation, setTouchActivation] = (0, react_1.useState)(getTouchActivationStrategy(activationInteractionTouch, handleIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold));
    const [mouseActivation, setMouseActivation] = (0, react_1.useState)(getMouseActivationStrategy(activationInteractionMouse, handleIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs));
    ///
    /// Functions
    ///
    const unsetShouldGuardAgainstMouseEmulationByDevices = () => {
        timersRef.current.push({
            name: constants_1.MOUSE_EMULATION_GUARD_TIMER_NAME,
            id: setTimeout(() => {
                setShouldGuardAgainstMouseEmulationByDevices(false);
            }, 0),
        });
    };
    const setPositionState = (newPosition) => {
        setIsPositionOutside(getIsPositionOutside(newPosition, elementDimensions));
        setPosition(newPosition);
    };
    const onMouseDetected = () => {
        onDetectedEnvironmentChanged({
            isTouchDetected: false,
            isMouseDetected: true,
        });
    };
    const handleTouchStart = (e) => {
        onDetectedEnvironmentChanged({
            isTouchDetected: true,
            isMouseDetected: false,
        });
        setShouldGuardAgainstMouseEmulationByDevices(true);
        const newPosition = observer.current.getCursorPosition(getTouchEvent(e));
        setPositionState(newPosition);
        touchActivation.touchStarted({ e, position: newPosition });
    };
    const handleMouseEnter = (e) => {
        if (shouldGuardAgainstMouseEmulationByDevices) {
            return;
        }
        onMouseDetected();
        setPositionState(observer.current.getCursorPosition(e));
        mouseActivation.mouseEntered();
    };
    const handleTouchEnd = () => {
        touchActivation.touchEnded();
        unsetShouldGuardAgainstMouseEmulationByDevices();
        // TODO destroy?
    };
    const handleTouchCancel = () => {
        touchActivation.touchCanceled();
        unsetShouldGuardAgainstMouseEmulationByDevices();
        // TODO destroy?
    };
    const handleMouseLeave = () => {
        mouseActivation.mouseLeft();
        setIsPositionOutside(true);
        // TODO destroy?
    };
    const handleTouchMove = (e) => {
        const newPosition = observer.current.getCursorPosition(getTouchEvent(e));
        touchActivation.touchMoved({ e, position: newPosition });
        if (isActive) {
            setPositionState(newPosition);
            e.preventDefault();
            if (shouldStopTouchMovePropagation) {
                e.stopPropagation();
            }
        }
    };
    const handleMouseMove = (e) => {
        const newPosition = observer.current.getCursorPosition(e);
        setPositionState(newPosition);
    };
    const handleClick = (e) => {
        setPositionState(observer.current.getCursorPosition(e));
        mouseActivation.mouseClicked();
        onMouseDetected();
    };
    const handleKeyDown = (e) => {
        e.preventDefault();
        setIsActive(true);
    };
    const handleKeyUp = (e) => {
        e.preventDefault();
        setIsActive(false);
    };
    const onDocumentMouseClick = (e) => {
        const el = e.target;
        const isDescendantOfRoot = divRef.current && el instanceof Node && divRef.current.contains(el);
        if (!isDescendantOfRoot) {
            onOutsideClick(e);
        }
    };
    const removeEventListeners = () => {
        document.removeEventListener('click', onDocumentMouseClick);
    };
    ///
    /// Effects
    ///
    (0, react_1.useEffect)(() => {
        removeEventListeners();
        if (isEnabled) {
            document.addEventListener('click', onDocumentMouseClick, { capture: useCapture });
        }
        return () => removeEventListeners();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isEnabled]);
    (0, react_1.useEffect)(() => {
        if (divRef.current) {
            observer.current.subject = divRef.current;
            // setElementDimensions(getElementDimensions(divRef.current));
        }
    }, [divRef]);
    (0, react_1.useEffect)(() => {
        onPositionChangedProp({
            isPositionOutside,
            position,
        });
        onActivationChanged({ isActive });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isActive]);
    (0, react_1.useEffect)(() => {
        onPositionChangedProp({
            isPositionOutside,
            position,
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isPositionOutside, position]);
    (0, react_1.useEffect)(() => {
        setTouchActivation(getTouchActivationStrategy(activationInteractionTouch, handleIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold));
        setMouseActivation(getMouseActivationStrategy(activationInteractionMouse, handleIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        activationInteractionMouse,
        activationInteractionTouch,
    ]);
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ ref: divRef, role: "button", style: Object.assign(Object.assign({}, style), { WebkitUserSelect: 'none' }), tabIndex: tabIndex, onClick: isEnabled ? handleClick : undefined, onKeyDown: isEnabled ? handleKeyDown : undefined, onKeyUp: isEnabled ? handleKeyUp : undefined, onMouseEnter: isEnabled ? handleMouseEnter : undefined, onMouseLeave: isEnabled ? handleMouseLeave : undefined, onMouseMove: isEnabled ? handleMouseMove : undefined, onTouchCancel: isEnabled ? handleTouchCancel : undefined, onTouchEnd: isEnabled ? handleTouchEnd : undefined, onTouchMove: isEnabled ? handleTouchMove : undefined, onTouchStart: isEnabled ? handleTouchStart : undefined }, rest, { children: children({
            isActive,
            isPositionOutside,
            elementDimensions,
            position,
        }) })));
};
exports.CursorPosition = CursorPosition;
//# sourceMappingURL=CursorPosition.js.map