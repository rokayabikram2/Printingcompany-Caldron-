"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactImageMagnify = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const detect_it_1 = require("detect-it");
const react_1 = require("react");
const MagnifyContainerPortal_1 = require("./MagnifyContainerPortal");
const negative_space_1 = require("./lens/negative-space");
const positive_space_1 = require("./lens/positive-space");
const DefaultHint_1 = require("./hint/DefaultHint");
const lens_1 = require("./lib/lens");
const dimensions_1 = require("./lib/dimensions");
const CursorPosition_1 = require("./CursorPosition");
const InPlaceMagnifyContainer_1 = require("./InPlaceMagnifyContainer");
const styles_1 = require("./lib/styles");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const shouldShowHint = (activationInteractionHint) => (activationInteractionHint === constants_1.INTERACTIONS.click
    || activationInteractionHint === constants_1.INTERACTIONS.hover);
const ReactImageMagnify = (props) => {
    var _a;
    const { activationInteractionHint, activationInteractionMouse = constants_1.INTERACTIONS.hover, activationInteractionTouch = constants_1.INTERACTIONS.press, fadeDurationInMs = 300, hintComponent: HintComponent = DefaultHint_1.DefaultHint, hintProps, isEnabled = true, imageComponent: ImageComponent = 'img', imageProps, lensComponent: LensComponentProp, lensProps, magnifyContainerProps, magnifiedImageComponent, magnifiedImageProps, portalProps: portalPropsProp, shouldUsePositiveSpaceLens = false, style } = props, rest = __rest(props, ["activationInteractionHint", "activationInteractionMouse", "activationInteractionTouch", "fadeDurationInMs", "hintComponent", "hintProps", "isEnabled", "imageComponent", "imageProps", "lensComponent", "lensProps", "magnifyContainerProps", "magnifiedImageComponent", "magnifiedImageProps", "portalProps", "shouldUsePositiveSpaceLens", "style"]);
    const { onLoad } = imageProps, usabledImageProps = __rest(imageProps, ["onLoad"]);
    const isZoomClickable = activationInteractionHint === constants_1.INTERACTIONS.click;
    // Prop Validation
    if (activationInteractionHint
        && activationInteractionMouse === constants_1.INTERACTIONS.click
        && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) !== 'production') {
        // eslint-disable-next-line no-console
        console.warn(`[ReactImageMagnify]
        Warning! "activationInteractionHint" is set to ${activationInteractionHint} and "activationInteractionMouse" is set to ${constants_1.INTERACTIONS.click}.
        These are incompatible options and may beahve unexpectedly.
        `);
    }
    ///
    /// Hooks
    ///
    const imageRef = (0, react_1.useRef)(null);
    const [smallImage, setSmallImage] = (0, react_1.useState)((0, utils_1.resolveSmallImage)(imageProps));
    const [isMouseDetected, setIsMouseDetected] = (0, react_1.useState)(detect_it_1.primaryInput === constants_1.INPUT_TYPE.mouse);
    const [isTouchDetected, setIsTouchDetected] = (0, react_1.useState)(detect_it_1.primaryInput === constants_1.INPUT_TYPE.touch);
    const [imageLoaded, setImageLoaded] = (0, react_1.useState)(false);
    const [lockedByHintInteraction, setLockedByHintInteraction] = (0, react_1.useState)(isZoomClickable);
    ///
    /// Derived data from state
    ///
    const portalProps = Object.assign(Object.assign({}, portalPropsProp), { placement: (portalPropsProp === null || portalPropsProp === void 0 ? void 0 : portalPropsProp.placement) || (isTouchDetected
            ? constants_1.MagnifiedImagePosition.OVER
            : constants_1.MagnifiedImagePosition.AUTO) });
    const isInPlaceMode = portalProps.placement === constants_1.MagnifiedImagePosition.OVER;
    const shouldShowLens = !isInPlaceMode && !isTouchDetected;
    ///
    /// Memos
    ///
    const resizeHandler = (0, react_1.useMemo)(() => () => (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps), []);
    const computedEnlargedImageContainerDimensions = (0, react_1.useMemo)(() => {
        var _a, _b;
        return ({
            width: (0, dimensions_1.getEnlargedImageContainerDimension)((magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.width) || constants_1.DEFAULT_MAGNIFY_CONTAINER_WIDTH, ((_a = imageRef === null || imageRef === void 0 ? void 0 : imageRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth) || smallImage.width || constants_1.DEFAULT_MAGNIFY_CONTAINER_WIDTH, magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.scale, isInPlaceMode),
            height: (0, dimensions_1.getEnlargedImageContainerDimension)((magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.height) || constants_1.DEFAULT_MAGNIFY_CONTAINER_HEIGHT, ((_b = imageRef === null || imageRef === void 0 ? void 0 : imageRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || smallImage.height || constants_1.DEFAULT_MAGNIFY_CONTAINER_HEIGHT, magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.scale, isInPlaceMode),
        });
    }, [magnifyContainerProps, smallImage, isInPlaceMode]);
    const cursorOffset = (0, react_1.useMemo)(() => (0, lens_1.getLensCursorOffset)((0, utils_1.imageToStrictDimensions)(smallImage, imageRef), magnifiedImageProps, computedEnlargedImageContainerDimensions), [computedEnlargedImageContainerDimensions, magnifiedImageProps, smallImage]);
    ///
    /// Effects
    ///
    (0, react_1.useEffect)(() => {
        setSmallImage((0, utils_1.resolveSmallImage)(imageProps));
    }, [imageProps]);
    (0, react_1.useEffect)(() => {
        setLockedByHintInteraction(activationInteractionHint === constants_1.INTERACTIONS.click);
    }, [activationInteractionHint]);
    (0, react_1.useEffect)(() => {
        if (!(0, utils_1.isFluid)(imageProps)) {
            (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps);
            window.addEventListener('resize', resizeHandler);
        }
        else {
            window.removeEventListener('resize', resizeHandler);
        }
        return () => window.removeEventListener('resize', resizeHandler);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [imageProps, imageRef]);
    ///
    /// Handlers
    ///
    const generateHintStyle = (hintPropsStyle) => {
        const hintStyle = Object.assign({}, hintPropsStyle);
        // Check and set via if-statements to prevent accidentally overriding existing
        // styles or styles that are set later
        if (lockedByHintInteraction) {
            hintStyle.cursor = 'pointer';
        }
        return hintStyle;
    };
    const handleDetectedEnvironmentChanged = (detectedInputType) => {
        setIsMouseDetected(detectedInputType.isMouseDetected);
        setIsTouchDetected(detectedInputType.isTouchDetected);
    };
    const handleHintClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setLockedByHintInteraction(false);
    };
    const handleHintTouchEnd = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setLockedByHintInteraction(false);
    };
    const handleOutsideClick = () => {
        if (isZoomClickable) {
            setLockedByHintInteraction(true);
        }
    };
    const onImageComplete = () => {
        if (!(0, utils_1.isFluid)(imageProps)) {
            (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps);
        }
        setImageLoaded(true);
    };
    const handleImageLoadOrComplete = (e) => {
        if (!imageLoaded) {
            if (smallImage.onLoad) {
                smallImage.onLoad(e);
            }
            onImageComplete();
        }
    };
    const HintComponentOrNull = activationInteractionHint && shouldShowHint(activationInteractionHint)
        ? ((0, jsx_runtime_1.jsx)(HintComponent, Object.assign({}, hintProps, { hintTextMouse: (hintProps === null || hintProps === void 0 ? void 0 : hintProps.hintTextMouse) || `${(0, utils_1.capitalize)(activationInteractionHint)} to Zoom`, hintTextTouch: (hintProps === null || hintProps === void 0 ? void 0 : hintProps.hintTextTouch) || 'Long-Touch to Zoom', isMouseDetected: isMouseDetected, isTouchDetected: isTouchDetected, style: generateHintStyle(hintProps === null || hintProps === void 0 ? void 0 : hintProps.style), onClick: lockedByHintInteraction ? handleHintClick : undefined, onTouchEnd: lockedByHintInteraction ? handleHintTouchEnd : undefined }))) : null;
    const LensComponent = LensComponentProp || shouldUsePositiveSpaceLens ? positive_space_1.PositiveSpaceLens : negative_space_1.NegativeSpaceLens;
    ///
    /// More Effects
    ///
    (0, react_1.useLayoutEffect)(() => {
        var _a;
        if ((_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.complete) {
            onImageComplete();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    (0, react_1.useEffect)(() => {
        if (imageRef.current) {
            imageRef.current.onload = handleImageLoadOrComplete;
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return ((0, jsx_runtime_1.jsx)(CursorPosition_1.CursorPosition, Object.assign({ shouldStopTouchMovePropagation: true, activationInteractionMouse: activationInteractionMouse, activationInteractionTouch: activationInteractionTouch, isEnabled: isEnabled, style: (0, styles_1.getContainerStyle)(smallImage, style, lockedByHintInteraction), onDetectedEnvironmentChanged: handleDetectedEnvironmentChanged, onOutsideClick: handleOutsideClick }, rest, { children: ({ position, isActive, isPositionOutside }) => ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(ImageComponent, Object.assign({}, usabledImageProps, { alt: smallImage.alt, ref: imageRef, style: (0, styles_1.getSmallImageStyle)(smallImage, imageProps.style) })), imageLoaded && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [HintComponentOrNull, shouldShowLens && !lockedByHintInteraction && ((0, jsx_runtime_1.jsx)(LensComponent, Object.assign({ cursorOffset: cursorOffset, fadeDurationInMs: fadeDurationInMs, isActive: isActive, isPositionOutside: isPositionOutside, position: position }, lensProps, { ref: imageRef }))), isInPlaceMode && !lockedByHintInteraction && ((0, jsx_runtime_1.jsx)(InPlaceMagnifyContainer_1.InPlaceMagnifyContainer, Object.assign({ containerDimensions: computedEnlargedImageContainerDimensions, cursorOffset: cursorOffset, fadeDurationInMs: fadeDurationInMs, imageComponent: magnifiedImageComponent, imageProps: magnifiedImageProps, isActive: isActive, isPositionOutside: isPositionOutside, position: position, sourceImageDimensions: (0, utils_1.imageToStrictDimensions)(smallImage, imageRef) }, magnifyContainerProps))), !isInPlaceMode && !lockedByHintInteraction && ((0, jsx_runtime_1.jsx)(MagnifyContainerPortal_1.MagnifyContainerPortal, Object.assign({ containerDimensions: computedEnlargedImageContainerDimensions, cursorOffset: cursorOffset, fadeDurationInMs: fadeDurationInMs, imageComponent: magnifiedImageComponent, imageProps: magnifiedImageProps, isActive: isActive, isPositionOutside: isPositionOutside, portalProps: portalProps, position: position, sourceImageDimensions: (0, utils_1.imageToStrictDimensions)(smallImage, imageRef) }, magnifyContainerProps, { ref: imageRef })))] }))] })) })));
};
exports.ReactImageMagnify = ReactImageMagnify;
//# sourceMappingURL=ReactImageMagnify.js.map